---
title: "Identification of co-deletions and co-amplification events in Cancer"
author: "Hodgkin2017"
date: "23 May 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyr)
library(dplyr)
library(org.Hs.eg.db)
library(pheatmap)
library(RColorBrewer)

### Set working directory
setwd("/Users/Matt/Documents/Masters_Bioinformatics/Internships/Code/co-deletions/")

### Load data
load("/Users/Matt/Documents/Masters_Bioinformatics/Internships/Input data/R workspaces/co-deletions workspace.RData")

```

## Hypothesis and Aims

Add something here.......

Aims:

1. Aim One
2. Aim Two
3. Aim Three

## Data source

Collection and geneotyping of Tumours was performed by the Cancer Genome atlas (TCGA) whose aim is to.....(write more?).  Tumour genotyping raw data was processed at the Broad Institute as part of the firehose project (http://firebrowse.org). The project aims to regularly process cancer genomic data from the TCGA using standardised methods for the benefit of the scientific community and by doing so reduce processing time and human error. 

To identify gene co-deletion and amplification events, GISTIC2 processed CNV data was downloaded from the broad Institutes firehose website (http://gdac.broadinstitute.org). From the [broad gdac homepage](http://gdac.broadinstitute.org) navigate to the *Analyses* drop down menu and choose *Dashboard*. This will take you to a page listing every cancer type with genotyping data processed by the firehose project (https://confluence.broadinstitute.org/display/GDAC/Dashboard-Analyses). To visualse all openly available (not protected) data files click on *Open* for each cancer type. The new webpage lists all .tar zipped files available to download. The files containing CNV data have **Gistic2** in their name. These files were downloaded for each cancer type from the 2016_01_28 analyses Run on the 15th May 2017.

To confirm that the data was downlaoded without any error a md5 checksum was performed on the downloaded files and the checksum code was compared to the .md5 files downloaded at the same time as the data files.

First concatenate the contents of the .md5 files into one file: 

```{bash md5_cat, eval=FALSE}
cat *Level_4*.md5 > /Users/Matt/Documents/co-deletions/md5_checksum_Level_4.txt
less /Users/Matt/Documents/co-deletions/md5_checksum_Level_4.txt

```

Next perform an md5 checksum operation on the Level_4 files (these files contain the data we want) and save the output as a file:

```{bash md5_checksum, eval=FALSE}
man md5

md5 -r *Level_4*.tar.gz
md5 -r *Level_4*.tar.gz > /Users/Matt/Documents/co-deletions/md5_checksum.txt

```

The md5_checksum files and downloaded .md5 files were imported into R and used to confirm the md5 checksum code was identical: 

```{r checksum_confirmation}
## Import files into R
md5.cat.files<- read.table(file = "/Users/Matt/Documents/Masters_Bioinformatics/Internships/Input data/md5 checksum GISTC2 firehose/md5_cat_Level_4.txt")
md5.checksum<- read.table(file = "/Users/Matt/Documents/Masters_Bioinformatics/Internships/Input data/md5 checksum GISTC2 firehose/md5_checksum.txt")

## Name columns of imported tables:
colnames(md5.cat.files)<- c("checksum", "file_name")
colnames(md5.checksum)<- c("checksum_download", "file_name")

## Join the imported tables and create a new column that proves if the md5 checksum code of the downloaded files matches with the true checksum code:
dplyr.checksum2<- dplyr::full_join(md5.cat.files, md5.checksum, by = "file_name") %>% 
  dplyr::mutate(identical_checksum = checksum == checksum_download)

## If sum is == 0 then all files have been corectly downloaded:
sum(!dplyr.checksum2$identical_checksum)
```

The download was successful as the md5 checksum code of the downloaded data files was identical to the code in the .md5 files. The individual \*Gistc2.Level4\* files were then unzipped using the following command:

```{bash unzip, eval=FALSE}

tar -zxvf gdac.broadinstitute.org_ACC-TP.CopyNumber_Gistic2.Level_4.2016012800.0.0.tar.gz

```

However, this method was very slow as all files could not be unzipped in one opperation. Therfore, it was quicker to double click each \*tar.gz file and unzip them using the MAC GUI.

A new folder was manually created for each cancer type and the unzipped files for each cancer type were transfered to the appropriately named folder.

## Import CNV data for each cancer type

An R script was used to import the CNV data files for each cancer type from their respective folders. All CNV data files were stored as individual dataframes in a single list object where each item of the list was named after the folder (cancer type) the dataframe was imported from.

```{r Import_data, eval=FALSE}

##F1: Function to import multiple files from multiple folders

import.files.from.directories<-function(path.to.dir,file.to.import){
  currentwd<- getwd()
  setwd(path.to.dir)
  directory.names<-dir()
  my.list <- vector("list", length(directory.names))
  for (i in 1: length(directory.names)){
    move.to.directory<-paste0(path.to.dir,"/",directory.names[i])
    setwd(move.to.directory)
    my.list[[i]]<-read.delim(file.to.import, stringsAsFactors = FALSE, header = TRUE)
    print(directory.names[i])
  }
  names(my.list)<- directory.names
  setwd(currentwd)
  my.list
}



## Choose directory and name of files to import from each directory:

x<-"/Users/Matt/Documents/Masters_Bioinformatics/Internships/Input data/unzipped original broad TCGA CNV data"
file.to.import<-"all_data_by_genes.txt"

##O1: Run function to obtain a list object containing all CNV dataframes

cnv.list<- import.files.from.directories(x, file.to.import)


```


## Confirm that each cancer type CNV file has the same genes and Locus IDs

Each CNV file for each cancer type was checked to ensure they each contained the same number of genes.

```{r unique_data}

#################
## Check that each CNV dataset contains the same genes and Entrez IDs (Locus.ID column):

##Make table of gene names
gene.names<- sapply(cnv.list, '[[',1)

##Sort gene names before checking each column is identical
gene.names.sorted <- apply(gene.names,2,sort,decreasing=F)

## A1: Check the gene names for each CNV dataset is identical
identical.gene.names<- rep(NA, ncol(gene.names.sorted))
for (i in 1: ncol(gene.names.sorted)){
  
  identical.gene.names[i]<- identical(gene.names.sorted[,1], gene.names.sorted[,i])
}
##O2:
identical.gene.names


##Make table of entrez IDs
Locus.IDs<- sapply(cnv.list, '[[',2)

##Sort entrez IDs before checking each column is identical
Locus.IDs.sorted <- apply(Locus.IDs,2,sort,decreasing=F)

## A2: Check the entrez IDs for each CNV dataset are identical
identical.Locus.IDs<- rep(NA, ncol(Locus.IDs.sorted))
for (i in 1: ncol(Locus.IDs.sorted)){
  
  identical.Locus.IDs[i]<- identical(Locus.IDs.sorted[,1], Locus.IDs.sorted[,i])
}
##O3:
identical.Locus.IDs


```


## Select Cancer type CNV data for analysis

A function was implemented in R that could create a single large dataframe from all or some of the cancer type datasets using the CNV list object above. This would allow specific cancer type CNV data sets to be interegated later if required.

```{r select_data, eval=FALSE}

##F2: Function to select some or all CNV datasets from CNV list object and combining data into one large dataframe.

join.cnv.datasets<- function(object_name, column = 4, data.sets = "ALL"){
  
  if(data.sets == "ALL"){
    
    index<- seq(1:length(object_name))
    
  } else {
    names.of.tables<-names(object_name)
    index<-which(names.of.tables %in% data.sets)
    print("DO NOT WORRY ABOUT THE FOLLOWING WARNING MESSAGE:")
    
  }
  
  df<- object_name[[1]] %>% dplyr::select(c(Gene.Symbol,Locus.ID,Cytoband))
  
  for (i in index){
    
    df2<-object_name[[i]][,c(1,column:ncol(object_name[[i]]))]
    
    df<- full_join(df, df2, by = "Gene.Symbol")
    
  }
  df
}

##O5: Create one large dataframe with all CNV data in it:
CNV.all.table<-join.cnv.datasets(cnv.list, column = 4)

```

## Appending start and end chromosomal locations to each gene in the CNV table 

Initially, my functions were designed to obtain the chromosomal locations of each gene in the cnv table every time they were run. However, this can take some time and therefore, this is now performed separately in one step below:

```{r chromosomal_locations, eval= FALSE}

##########
### F1: Obtain chromosomal locations of genes

chromosomal_location<- function(object_name){
  
  ##Variables I want:
  keys<- as.character(object_name$Locus.ID)
  columns<- c("CHR", "CHRLOC", "CHRLOCEND")
  
  ## Search for gene chromosomal locations:
  genes.of.interest<- AnnotationDbi::select(org.Hs.eg.db, keys, columns, keytype = "ENTREZID")
  
  ## Remove duplicated entries:
  genes.of.interest<- na.omit(genes.of.interest[!duplicated(genes.of.interest$ENTREZID), ])
  
  ## Add additional columns to dataframe including strand, gene start and end:
  genes.of.interest$strand<- ifelse(genes.of.interest$CHRLOC <0, "-", "+")
  genes.of.interest$start<- abs(genes.of.interest$CHRLOC)
  genes.of.interest$end<- abs(genes.of.interest$CHRLOCEND)

  ##########
  ###Join gene location dataframe to original CNV data table
  
  ##Rename ENTREZID column so it can be joined to oringinal dataframe:
  genes.of.interest<- dplyr::rename(genes.of.interest, Locus.ID = ENTREZID)
  
  genes.of.interest$Locus.ID<- as.integer(genes.of.interest$Locus.ID)
  
  genes.of.interest<- full_join(genes.of.interest,object_name, by="Locus.ID")
  
  ##########
  ### Order genes by chromosome and location:
  
  ## Rename X and Y chromosomes to integer so they can be properly sorted.
  genes.of.interest$CHR<-sub("X", "23", genes.of.interest$CHR)
  genes.of.interest$CHR<-sub("Y", "24", genes.of.interest$CHR)
  genes.of.interest$CHR<- as.integer(genes.of.interest$CHR)
  genes.of.interest<- dplyr::arrange(genes.of.interest, CHR, start)
  genes.of.interest$CHR<-sub("23","X",  genes.of.interest$CHR)
  genes.of.interest$CHR<-sub("24", "Y", genes.of.interest$CHR)
  
  return(genes.of.interest)
}



```



## Heatmaps showing co-deletions and co-amplifications for each chromosome for all types of tumours
Function that creates matrix and normalises data of your choice and plots heat map.

Function must allow for interrogation of specific genes, cytobands, chromosomes and chromosomal locations.......

use ... for pHeatmap arguments?

**This is definatley still a work in progress!!!!!!:
I will clean this up and modify to accept different inputs such as gene names, gene IDs and chromosomal locations.**

```{r co-deletions_heatmap}

##########
## Obtain chromosomal locations of genes

##Temporary 
acc.cnv<- cnv.list[[1]]

keys<- keys(org.Hs.eg.db, keytype = "ENTREZID")

columns<- c("CHR", "CHRLOC", "CHRLOCEND")
sel<- AnnotationDbi::select(org.Hs.eg.db, keys, columns, keytype = "ENTREZID")


acc.locus.id<- acc.cnv$Locus.ID


sel2<- sel[sel$ENTREZID %in% acc.locus.id,]


sel3<- na.omit(sel2[!duplicated(sel2$ENTREZID), ])

    
## Remove genes with poorly defined chromosome
chr<-c(seq(1:22), "X", "Y")


rows.of.interest<- which(sel3$CHR %in% chr)


sel3.final<- sel3[rows.of.interest,]



sel3.final$strand<- ifelse(sel3.final$CHRLOC <0, "-", "+")

sel3.final$start<- abs(sel3.final$CHRLOC)
sel3.final$end<- abs(sel3.final$CHRLOCEND)


##which genes did not have defined chromosome
# rows.not.of.interest<-which(!sel3$CHR %in% chr)
# length(which(!sel3$CHR %in% chr))
# genes.removed.from.sel3<- sel3[rows.not.of.interest,]
# head(genes.removed.from.sel3)

#################
## Attach CHRLOCCHR and start to acc cnv file

sel3.final<- dplyr::rename(sel3.final, Locus.ID = ENTREZID)

#class(acc.cnv$Locus.ID)
#class(sel3$Locus.ID)
sel3.final$Locus.ID<- as.integer(sel3.final$Locus.ID)
#class(sel3$Locus.ID)

acc.cnv.loc<- full_join(sel3.final,acc.cnv, by="Locus.ID")
#head(acc.cnv.loc)
#class(acc.cnv.loc$CHR)
acc.cnv.loc$CHR<- as.integer(acc.cnv.loc$CHR)

#is.na(acc.cnv.loc$CHR)
#which(is.na(acc.cnv.loc), arr.ind = TRUE)
#dim(acc.cnv.loc)
acc.cnv.loc<- dplyr::arrange(acc.cnv.loc, CHR, start)
#View(acc.cnv.loc)

## comment: No Y chromosome...check intersection of genes on both X and Y and a lot of NA's!!


################
##Faster function to create matrix of proportions of co-deletions
# and co-amplifications

create.heatmap.matrix.ampl.del.optimised<- function(x, column_start, threshold, deletion = TRUE){
  
  ##Convert CNV data to matrix:
  
  cnv.matrix<- as.matrix(x[,column_start:ncol(x)])
  
  ##Create a binary matrix of CNV data such that deletions (deletion = TRUE) or 
  #amplifications (deletion = FALSE) below (for deletions) or above (for amplifications) a threshold = 1 
  if (deletion == TRUE) {
    
    #cnv.matrix[cnv.matrix > threshold] = 0
    #cnv.matrix = -cnv.matrix
    cnv.matrix<- ifelse(cnv.matrix <= threshold, 1, 0)
    
  } else {
    
    #cnv.matrix<- cnv.matrix >= threshold
    #cnv.matrix[cnv.matrix < threshold] = 0
    cnv.matrix<- ifelse(cnv.matrix >= threshold, 1, 0)
  }
  
  ## Calculate the proportion of individuals with a deletion:
  prop.individ.with.del<- rowSums(cnv.matrix)/ncol(cnv.matrix)
  
  ## Calculate total number of co-deletions of amplifications
  
  heatmap.matrix<- cnv.matrix%*%t(cnv.matrix)
  
  ##How to normalise?
  #heatmap.matrix<- heatmap.matrix/rowSums(cnv.matrix)
  heatmap.matrix<- heatmap.matrix/ncol(cnv.matrix)
  
  ##NaN caused when rowSums = 0. Replace NaN with 0
  #cnv.matrix[cnv.matrix == NaN] = 0
  heatmap.matrix[is.nan(heatmap.matrix)] = 0
  
  ## Complete diagonals with proportion of individuals with deletions.
  for(i in 1:nrow(heatmap.matrix)) {
    
    heatmap.matrix[i,i]<- prop.individ.with.del[i]
  }
  
  ## Add row and column names
  rownames(heatmap.matrix)<- rownames(x)
  colnames(heatmap.matrix)<- rownames(x)
  
  heatmap.matrix
}




##New optimised function
rownames(acc.cnv.loc)<- acc.cnv.loc$Gene.Symbol
x<- acc.cnv.loc

system.time(heatmap.matrix.del<- create.heatmap.matrix.ampl.del.optimised(x, column_start = 11, threshold = -1, deletion = TRUE))


system.time(heatmap.matrix.amp<- create.heatmap.matrix.ampl.del.optimised(x, column_start = 11, threshold = 1, deletion = FALSE))

```

```{r chromosome9_heatmaps}

####################
### Plot heatmaps: 
##deletion:

which(acc.cnv.loc$CHR == 9, arr.ind = TRUE)
chr9.heatmap.matrix.del<- heatmap.matrix.del[7809:8538,7809:8538]

col.pal <- RColorBrewer::brewer.pal(9, "YlGnBu")

pheatmap(chr9.heatmap.matrix.del,
         cluster_row = F,
         cluster_cols = F,
         #fontsize = 6.5,
         #fontsize_row=0.5, 
         #fontsize_col = 0.5,
         show_rownames = FALSE,
         show_colnames = FALSE
         #cellwidth = 0.8,
         #cellheight = 0.8 
         )


pheatmap(chr9.heatmap.matrix.del,
         cluster_row = T,
         cluster_cols = F,
         #fontsize = 6.5,
         #fontsize_row=0.3, 
         #fontsize_col = 0.3,
         show_rownames = FALSE,
         show_colnames = FALSE
         #cellwidth = 0.3,
         #cellheight = 0.3 
)

##Amplification:
chr9.heatmap.matrix.amp<- heatmap.matrix.amp[7809:8538,7809:8538]

pheatmap(chr9.heatmap.matrix.amp,
         cluster_row = F,
         cluster_cols = F,
         #fontsize = 6.5,
         #fontsize_row=0.3, 
         #fontsize_col = 0.3,
         show_rownames = FALSE,
         show_colnames = FALSE
         #cellwidth = 0.3,
         #cellheight = 0.3 
)

pheatmap(chr9.heatmap.matrix.amp,
         cluster_row = T,
         cluster_cols = F,
         #fontsize = 6.5,
         #fontsize_row=0.5, 
         #fontsize_col = 0.5,
         show_rownames = FALSE,
         show_colnames = FALSE
         #cellwidth = 0.8,
         #cellheight = 0.8 
)



```
## Heatmaps showing number of deletions per cytoband/chromosomal interval

Function to calculate the number of deletions or amplifications per cytoband or chromosomal interval


```{r cytobands_chromosomal_interval_function, eval= FALSE}

#############
### F1: Function: events.per.cytoband

events.per.cytoband<- function(x, threshold, cytoband_column, column_data_start, chromosome_interval = 0, select_chromosome, deletion = TRUE){
  
  ##########
  ### Obtain chromosomal locations of genes
  
  keys<- keys(org.Hs.eg.db, keytype = "ENTREZID")
  columns<- c("CHR", "CHRLOC", "CHRLOCEND")
  all.gene.locations<- AnnotationDbi::select(org.Hs.eg.db, keys, columns, keytype = "ENTREZID")
  
  locus.id<- x$Locus.ID
  
  genes.of.interest<- all.gene.locations[all.gene.locations$ENTREZID %in% locus.id,]
  
  genes.of.interest<- na.omit(genes.of.interest[!duplicated(genes.of.interest$ENTREZID), ])
  
  ## Remove genes with poorly defined chromosome
  chr<-c(seq(1:22), "X", "Y")
  
  rows.of.interest<- which(genes.of.interest$CHR %in% chr)
  
  genes.of.interest<- genes.of.interest[rows.of.interest,]
  
  genes.of.interest$strand<- ifelse(genes.of.interest$CHRLOC <0, "-", "+")
  genes.of.interest$start<- abs(genes.of.interest$CHRLOC)
  genes.of.interest$end<- abs(genes.of.interest$CHRLOCEND)
  
  ##########
  ###Join gene location dataframe to original CNV data table
  
  genes.of.interest<- dplyr::rename(genes.of.interest, Locus.ID = ENTREZID)
  
  genes.of.interest$Locus.ID<- as.integer(genes.of.interest$Locus.ID)
  
  genes.of.interest<- full_join(genes.of.interest,x, by="Locus.ID")
  
  ##########
  ## Order genes by chromosome and location:
  genes.of.interest<- dplyr::arrange(genes.of.interest, CHR, start)
  
  column_data_start<- column_data_start + 7
  cytoband_column<- cytoband_column + 7
  
  #############
  ## Create matrix containing CNV data only:
  cnv.matrix<- as.matrix(genes.of.interest[,column_data_start:ncol(genes.of.interest)])
  
  ##############
  ## Convert CNV data into binary object with 1 representing a deletion or amplification
  #event has occurred:
  if (deletion == TRUE) {
    
    cnv.matrix<- ifelse(cnv.matrix <= threshold, 1, 0)
    
  } else {
    
    cnv.matrix<- ifelse(cnv.matrix >= threshold, 1, 0)
  }
  
  ##Create list to store data:
  if (chromosome_interval == 0){
    results <- vector("list", 2)
  } else {
    results <- vector("list", 4)
  }
  
  ##Create matrix with raw deletions/amplification values and number of 
  #deletions/amplifications per gene
  results[[1]]<- cnv.matrix %>% 
    as.data.frame() %>% 
    dplyr::mutate(sum.of.deletions = rowSums(.)) %>%
    dplyr::mutate(number.of.tumours = ncol(.)-1) %>%
    cbind(cytoband=genes.of.interest[,cytoband_column], 
          chromosome = genes.of.interest$CHR, 
          start = genes.of.interest$start, .) 
  
  ##Create dataframe with number of deletions per gene, number of genes and number of 
  #potenatial deletion events that could occur
  results[[2]]<- results[[1]]%>%
    group_by(cytoband) %>%
    dplyr::summarise(sum.of.genes.deleted = sum(sum.of.deletions),
                     total.number.of.genes=n(),
                     total.number.of.events = sum(number.of.tumours)) %>%
    dplyr::mutate(proportion.of.deletions = sum.of.genes.deleted/total.number.of.events) %>%
    tidyr::separate(cytoband, c("chromosome", "band"), sep = "[p:q]", remove = FALSE, convert = TRUE)
  #dplyr::select(-band) %>%
  
  ## Arrange dataframe by chromosome and cytoband:
  results[[2]]$chromosome<-sub("X", "23", results[[2]]$chromosome)
  results[[2]]$chromosome<-sub("Y", "24", results[[2]]$chromosome)
  results[[2]]$chromosome<- as.integer(results[[2]]$chromosome)
  results[[2]]<- dplyr::arrange(results[[2]], chromosome, cytoband)
  results[[2]]$chromosome<-sub("23", "X", results[[2]]$chromosome)
  results[[2]]$chromosome<-sub("24", "Y", results[[2]]$chromosome)
  
  ##############
  ### Create tables with the number of deletions/amplifications per chromosome interval:
  ## Table of chromosome intervals:
  if (chromosome_interval > 0){
    ## Very rough estimate of lengths of chromosomes:
    results[[3]]<- results[[1]] %>%
      group_by(chromosome) %>%
      summarise(chromosome_start = min(start),
                chromosome_end = max(start)) %>%
      mutate(estimated_chromosome_length = chromosome_end - chromosome_start,
             intervals_for_kb = estimated_chromosome_length/1000,
             intervals_for_10kb = estimated_chromosome_length/10000,
             intervals_for_100kb = estimated_chromosome_length/100000,
             intervals_for_Mb = estimated_chromosome_length/1000000,
             intervals_for_10Mb = estimated_chromosome_length/10000000)
    
    ## Table with the number of deletions/amplifications per chromosome interval:
    filter.table<- results[[1]] %>%
      dplyr::filter(chromosome == select_chromosome)
    
    results[[4]]<- filter.table$start %>%
      cut(chromosome_interval, labels = seq(1:chromosome_interval)) %>%
      cbind(Intervals = ., filter.table) %>%
      dplyr::group_by(Intervals) %>%
      dplyr::summarise(sum.of.genes.deleted = sum(sum.of.deletions),
                       total.number.of.genes=n(),
                       total.number.of.potential.events = sum(number.of.tumours)) %>%
      dplyr::mutate(proportion.of.deletions = sum.of.genes.deleted/total.number.of.potential.events)
  }
  
  results
}


```

### Deletion of genes is highly variable between cytobands

Heatmaps showing proportion of deletions within each cytoband. Unclustered or clustered on Tumour type.
Annotation side bar = chromosome.

```{r deletion_cytobands}

#################
###Deletion heatmap:

cancer.type<- names(cnv.list)

## Matrix to store output of for loop
heatmap.matrix.cytoband.del<- matrix(NA, ncol = length(cancer.type)+1, nrow = 806)

##Loop of events.per.cytoband function and extraction of proportion of deletions into matrix
for (i in 1:length(cancer.type)){
  
  x<-cnv.list[[i]]
  cytoband.list<- events.per.cytoband(x, threshold = -1, cytoband_column = 3, column_data_start = 4, chromosome_interval = 0,  deletion = TRUE)
  heatmap.matrix.cytoband.del[,i]<- cytoband.list[[2]]$proportion.of.deletions
  print(cancer.type[i])
}

###########
###Final column of matrix will contain the proportion of deletions for all cancer types:

##Create one large dataframe with all CNV data in it using my join.cnv.datasets function:
x<-join.cnv.datasets(cnv.list, 4)

##Calculate proportion of deletions per cytoband and add to matrix
cytoband.list<- events.per.cytoband(x, threshold = -1, cytoband_column = 3, column_data_start = 4, chromosome_interval = 0,  deletion = TRUE)
heatmap.matrix.cytoband.del[,38]<- cytoband.list[[2]]$proportion.of.deletions

##Add row and column names
rownames(heatmap.matrix.cytoband.del)<- cytoband.list[[2]]$cytoband
colnames(heatmap.matrix.cytoband.del)<- c(cancer.type, "ALL")
  
##Make annotation row dataframe for heatmap
annotation_row<- data.frame(chromosome = cytoband.list[[2]]$chromosome)
rownames(annotation_row)<- cytoband.list[[2]]$cytoband

col.pal<- colorRampPalette(c("white", "navy", "firebrick3"))(1000)

pheatmap(heatmap.matrix.cytoband.del[,1:38],
         cluster_row = F,
         cluster_cols = F,
         show_rownames = TRUE,
         show_colnames = TRUE,
         color = col.pal,
         fontsize_row=1,
         #cellwidth = 10,
         annotation_row = annotation_row,
         annotation_legend = FALSE
)

pheatmap(heatmap.matrix.cytoband.del[,1:37],
         cluster_row = F,
         cluster_cols = T,
         show_rownames = TRUE,
         show_colnames = TRUE,
         color = col.pal,
         fontsize_row=1,
         #cellwidth = 10,
         annotation_row = annotation_row,
         annotation_legend = FALSE
)

```

### Amplification of genes is highly variable between cytobands



```{r amplifications_cytobands}

#################
###Amplification heatmap:

## Matrix to store output of for loop
heatmap.matrix.cytoband.ampl<- matrix(NA, ncol = length(cancer.type)+1, nrow = 806)

##Loop of events.per.cytoband function and extraction of proportion of deletions into matrix

for (i in 1:length(cancer.type)){
  
  x<-cnv.list[[i]]
  cytoband.list<- events.per.cytoband(x, threshold = 1, cytoband_column = 3, column_data_start = 4, chromosome_interval = 0,  deletion = FALSE)
  heatmap.matrix.cytoband.ampl[,i]<- cytoband.list[[2]]$proportion.of.deletions
  print(cancer.type[i])
}

###########
###Final column of matrix will contain the proportion of deletions for all cancer types:

##Create one large dataframe with all CNV data in it:
x<-join.cnv.datasets(cnv.list, 4)

##Calculate proportion of deletions per cytoband and add to matrix
cytoband.list<- events.per.cytoband(x, threshold = 1, cytoband_column = 3, column_data_start = 4, chromosome_interval = 0,  deletion = FALSE)
heatmap.matrix.cytoband.ampl[,38]<- cytoband.list[[2]]$proportion.of.deletions

##Add row and column names

rownames(heatmap.matrix.cytoband.ampl)<- cytoband.list[[2]]$cytoband
colnames(heatmap.matrix.cytoband.ampl)<- c(cancer.type, "ALL")

##Make annotation row dataframe

annotation_row<- data.frame(chromosome = cytoband.list[[2]]$chromosome)
rownames(annotation_row)<- cytoband.list[[2]]$cytoband

##Make heat map

pheatmap(heatmap.matrix.cytoband.ampl[,1:38],
         cluster_row = F,
         cluster_cols = F,
         show_rownames = TRUE,
         show_colnames = TRUE,
         color = col.pal,
         fontsize_row=1,
         #cellwidth = 10,
         annotation_row = annotation_row,
         annotation_legend = FALSE
)

pheatmap(heatmap.matrix.cytoband.ampl[,1:37],
         cluster_row = F,
         cluster_cols = T,
         show_rownames = TRUE,
         show_colnames = TRUE,
         color = col.pal,
         fontsize_row=1,
         #cellwidth = 10,
         annotation_row = annotation_row,
         annotation_legend = FALSE
)

```

### Deletion of genes is highly variable accross the genome

Cut function to split chromosome into segments need some work as not very accuarate:

```{r deletion_chromosome_interval}
################
#### Heatmaps of proportion of deletions/amplifications per MB for each chromosome and plot heatmap.
##################

##################
### Sum of deletions for all tumour types together:
##Comment: Could make an array to store all chromosomes for each tumour type.

##Intervals to split each chromosome into to achieve 1Mbase resolution (obtained from 
#previous analysis)
#chromosome_interval_1MB<- ceiling(cytoband.list[[3]]$intervals_for_Mb)
chromosome_interval_1MB<- c(249, 134, 135, 134, 101,  87,  97,  90,  83,  80,  59, 242,  65,  47,  51, 198, 191, 182, 171, 159, 146, 138, 156)

##Matrix to store results per chromosome:
heatmap.matrix.chr.interval250<- data.frame(matrix(NA, ncol = 1, nrow = 2500))
dim(heatmap.matrix.chr.interval250)
heatmap.matrix.chr.interval250[,1]<-seq(1:2500)
colnames(heatmap.matrix.chr.interval250)<-c("intervals")
colnames(heatmap.matrix.chr.interval250)
chr<-c(seq(1:22), "X")

##Calculate proportion of deletions per cytoband and add to matrix
for (i in 1:23) {
  j<-chr[i]
  chromosome_interval<-chromosome_interval_1MB[i]
cytoband.list<- events.per.cytoband(x, threshold = -1, cytoband_column = 3, column_data_start = 4, select_chromosome = j , chromosome_interval = chromosome_interval,  deletion = TRUE)
y<-data.frame(intervals = seq(1:length(cytoband.list[[4]]$proportion.of.deletions)), chr = cytoband.list[[4]]$proportion.of.deletions)

heatmap.matrix.chr.interval250<- full_join(heatmap.matrix.chr.interval250, y, by = "intervals")

#print(i)
#print(length(cytoband.list[[4]]$proportion.of.deletions))
}

colnames(heatmap.matrix.chr.interval250)<- c("Interval", paste0("Chromosome ", seq(1:22)), "Chromosome X")

##############
### Plot heatmaps

col.pal<- colorRampPalette(c( "white","navy", "firebrick3"))(1000)

pheatmap(heatmap.matrix.chr.interval250[1:205,2:24],
         cluster_row = F,
         cluster_cols = F,
         show_rownames = FALSE,
         show_colnames = TRUE,
         color = col.pal,
         fontsize_row=1
         #cellwidth = 10,
         #annotation_row = annotation_row,
         #annotation_legend = FALSE
)
```

